<html>
    <head>
        <title>{{title}}</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

        <!-- Latest compiled and minified CSS -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

        <!-- Optional theme -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

        <!-- Latest compiled and minified JavaScript -->
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

        <link rel="stylesheet" href="https://static.mall-lab.com/static/css/xterm-3.11.0.css" />
        <script src="https://static.mall-lab.com/static/js/xterm-3.11.0.js"></script>


        <style>

        #terminal-graph-container{
            overflow:hidden;
        }

        #terminal-graph{
            height:600px;
            overflow-y:scroll;
            //margin-top: 40px;
        }

        #terminal{
            margin-top: 40px;
        }

        .figure{
            margin-bottom:30px;
        }

        @media only screen and (max-width: 1200px) {
            .figure{
                margin-bottom:30px;
                width: 250px;
                float: left;
            }

        }

        .figure-caption{
            text-align:center;
        }

        .modal-outer {
            background-color: rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
        }
        .modal-inner {
            background-color: #fff;
            width: 50%;
            padding: 25px;
            margin: 25% auto;
            min-height: 260px;
            z-index: 1000;
            max-width: 700px;
        }

        .figures-close{
            color:#CCC; 
            float:right; 
            font-size:2em;
        }
        .figures-close:hover{
            color:#000; 
            cursor: pointer;
        }


        </style>
    </head>
    <body>
    <div class="loader"></div>
    <div class="col-lg-9" id="terminal-container">
        <div id="terminal"></div>
    </div>
    <div class="col-lg-3" id="terminal-graph-container">
        <div class="" id="terminal-graph"></div>
    </div>
    <div id="size-not-lg" class="hidden-lg hidden-xl"></div> 



<div style="display: none;" class="figures-outer modal-outer">
    <div style="text-align:center;" class="figures-inner modal-inner">
    <span class="glyphicon glyphicon-remove figures-close"></span>
        <img class="img-responsive" id="figures-img" src="" />
        <div id="figures-caption"></div>
    </div>
</div>


<script type="text/javascript">
term = null;
// Need these to global as we might need to resize the terminal

var input = "" // Current user input
var saveInput = "" // Retain user input when using up/down arrow keys
var inputHistory = [] // History of past inputs
var historyIndex = 0 // Used to iterate through input history
var cursorIndex = 0 // Where the cursor should be relative to input
var post = "" // Segment of current user input located behind cursor
var figures = 0; 

function createTerminal() {

    // Terminal size
    var rows = 25;
    var cols = 95;

    // The following is a messy hack to get the sizing 'sort-of' right
    // looking forward to xterm.js doing the work here with 'addons/fit'
   
    var winwidth = $(window).width() ;
    cols = Math.min(parseInt(winwidth/10, 10), 140);
    if( winwidth > 1200) cols = 95;
    if( winwidth > 1300) cols = 110;
    if( winwidth > 1400) cols = 120;
    if( winwidth > 1600) cols = 130;
    if( winwidth > 1700) cols = 140;

    if (! $("#size-not-lg").is(":visible")){
        // We have a large screen
        console.log("We have large screen");
        rows = 35;
        $("#terminal-graph").height("800px");
    }
    
    // Initiate terminal
    term = new Terminal({cursorBlink: true, cursorStyle: "bar", cols:cols, rows:rows})
    term.open(document.getElementById('terminal'))
    term.writeln(" Welcome to Private")

    var prompt = ' > ';
    term.prompt = function () {
        term.write('\r\n' + prompt)
        input = ""
    };
    term.prompt()

    // ---------------- Needs to send and receive data via ajax ----------------- //

    term.write_response = function(res) {
      console.log("term.write_response", res);
      term.write("\r\n   ")
      term.writeln(res.replace(/\n/g, "\r\n   "));
    }

    term.send_cmd = function(cmd) {
      console.log("term.send_cmd", cmd);
        if (!cmd) return;

        //write_cmd(cmd);
        data = { 'cmd': cmd, 'project_id': '{{project_id}}', 'uid': '{{uid}}' };

        $.ajax({
            type: "POST",
            url: '/analyze',
            data: data,
            success: function(data){
                console.log("ajax:success:cmd", cmd, data);
                if(data.type == 'graph'){
                    term.show_graph(cmd, data)
                }else if(data.response){
                    term.write_response(data.response)
                }
                callback();
            },
            fail: function(xhr, textStatus, errorThrown) {
              console.log("ajax:fail:cmd", cmd);
              callback()
            },
            dataType: "json"
        });
    }

    term.is_def = function(cmd){
        var startswith_def = /^def\s+\w[^:]+:$/;
        return cmd.match(startswith_def);
    }

    term.end_def = function(cmd){
        var return_def = /^\s{4}return(?:\s+\w|(?:\s+)?\()/;
        if (cmd.match(return_def)){
            return true;
        }

        var startswith = /^\s{4}[^\s]/;
        if( cmd.match(startswith) ){
            return false;
        }
    
        //Cover cases of malformed and empty input
        //Submit function and let parser raise exception
        return true;
    }

    term.show_graph = function(cmd, data){
        
        console.log("term.show_graph", cmd, data);
        var graph_display = document.getElementById('terminal-graph');
        while(graph_display.firstchild){
            graph_display.removeChild(graph_display.firstChild);
        }
        var figid = "figure-" + figures++;
        var figure = document.createElement('div');
        figure.id = figid + "-container";

        figure.classList.add('figure');

        var img = document.createElement('img');
        img.classList.add('center-block');
        img.classList.add('img-responsive');
        img.src = data.response;
        img.id = figid;

        figure.appendChild(img);
    
        var figure_caption = document.createElement('div');
        figure_caption.innerHTML = cmd;
        figure_caption.classList.add('figure-caption');
        figure.appendChild(figure_caption);

        
        graph_display.insertBefore(figure, graph_display.firstChild);
        //graph_display.scrollTop = graph_display.scrollHeight;

        $("#"+figid+"-container").on('touchstart click', function(event){
            if(event.handled === false) return
            event.stopPropagation();
            event.preventDefault();
            event.handled = true;
           
            $("#figures-img").prop("src", data.response);
            $("#figures-caption").text(cmd);
            $(".figures-outer").fadeIn('slow');
            
        });
    }

    term._record_function = null;


    term.enter = function () {
        // Enter key has been pressed

        console.log("term.enter", input);
        if(term._record_function){ 
            term._record_function += input + ";";
            console.log(term._record_function);
            if( term.end_def(input)){
                console.log("def exit");
                term.send_cmd(term._record_function)
                term._record_function = null;
            }else{
                callback();
            }
            return true;
            
        }
        if(term.is_def(input)){
            console.log("def start");
            term._record_function = input + '\n';
            callback();
            return true;
        }
        

        var cmd = $.trim(input);
        
        term.send_cmd(cmd);
        $("#cmd").val("");

    }

    callback = function() {
        // Call this function after ajax processes are complete
        console.log("callback");

        // Save the input
        if (input != inputHistory[inputHistory.length - 1]) {
            // Don't want to save the same command twice
            inputHistory.push(input)
        }

        // Reset counts
        historyIndex = inputHistory.length
        cursorIndex = 0
        post = ""

        // Start a new line
        term.prompt()
    }

    // -------------------------------------------------------------------------- //

    term.deleteLine = function () {
        // Deletes all of the text (asides from the prompt) on the current
        // line
        console.log("term.deleteLine");

        while (cursorIndex < input.length + 1) {
            // Make sure we're at the end of the line
            term.bringCursorForwards(1)
            cursorIndex += 1
        }
        while (input.length > 0) {
            term.write('\b \b')
            input = input.slice(0, -1)
        }
        cursorIndex = 0
    }


    term.bringCursorBackwards = function (n) {
        console.log("term.bringCursorBackwards");
        // Brings the cursor backwards by n
        for (var i = 0; i < n; i++) {
            term.write('\x1b[D')
        }
    }

    term.bringCursorForwards = function (n) {
        console.log("term.bringCursorForwards");
        // Brings the cursor forward by n
        for (var i = 0; i < n; i++) {
            term.write('\x1b[C')
        }
    }


    term.on('paste', function (rawdata, ev) {
        console.log("paste")
        rawdata = $.trim(rawdata) + "\r";

        // xterm has already converted the newline
        // character to mac format (\r) otherwise 
        // would have used \r?\n instead of \r below
        var re_def = /^def\s+.+\r(?:\s{4}.+\r)+/gm;

        var m;
        var defs = []
        var keep = Array.apply(null, Array(rawdata.length)).map(function() { return true }); 

        var chunks = [];
        while(m = re_def.exec(rawdata)){

            // Format def
            var mlen = m[0].length;
            var mindex = m.index;
            var d = m[0].split(/\r/);
            var start = d[0] + '\n';
            var end = d.slice(1);
            var df = start + end.join(";");
            chunks.push(df);


            // Remove characters
            for (var i = mindex; i < mindex+mlen; i++){
                keep[i] = false;
            }

        }

        rawdata_keep = "";
        for (var i = 0; i < rawdata.length; i++){
            if(keep[i]) rawdata_keep += rawdata[i];
        }

        
        
        chunks = chunks.concat( rawdata_keep.split(/\r/) );
        

        if (chunks.length > 1){
            
            paste_input = input
            for (var i = 0; i < chunks.length; i++){
                data = chunks[i];
                if (! data) continue;
                // Save the stuff before and after the position at which we're
                // pasting
                if (i == 0){
                    pre = paste_input.slice(0, cursorIndex)
                }else{
                    pre = ""
                }

                pki = cursorIndex

                // Clear the line
                term.deleteLine()
                term.write('\b \b')

                // Write the new user input
                paste_input = pre + data + post
                term.write(paste_input)

                // Bring the cursor back to where it should be after pasting
                if((i + 1) == chunks.length){
                    term.bringCursorBackwards(post.length)
                    cursorIndex = pre.length + paste_input.length
                }else{
                    cursorIndex = 0;
                    term.prompt();
                }



                //term.enter();
            }
            input = chunks.join("\r");

        }else{
            // Save the stuff before and after the position at which we're
            // pasting
            pre = input.slice(0, cursorIndex)
            pki = cursorIndex

            // Clear the line
            term.deleteLine()
            term.write('\b \b')

            // Write the new user input
            input = pre + rawdata + post
            term.write(input)

            // Bring the cursor back to where it should be after pasting
            term.bringCursorBackwards(post.length)
            cursorIndex = pre.length + rawdata.length

        }
    });


    term.on('key', function (key, ev) {
        var printable = (
            !ev.altKey && !ev.altGraphKey && !ev.ctrlKey && !ev.metaKey
        );

        if (ev.key == 'Enter') {
            // enter
            console.log("key: Enter"); 
            term.enter()

        } else if (ev.key == 'Backspace') {
            // backspace
            console.log("key: Backspace"); 
            if (input.slice(0, cursorIndex).length > 0) {
                // So we don't delete the prompt
                term.write('\b \b')

                if (post.length == 0) {
                    // Cursor is at the end of the line, simply cut down
                    input = input.slice(0, -1)
                    post = ""
                } else {
                    // We need to move post back

                    // Save the stuff from before the cursor
                    pre = input.slice(0, cursorIndex - 1)
                    tki = cursorIndex

                    // Clear the line
                    term.deleteLine()
                    cursorIndex = tki

                    // Write the new input, with post being pushed back by one
                    input = pre + post
                    term.write(input)
                    term.bringCursorBackwards(post.length)
                    post = input.slice(cursorIndex-1)
                }
                cursorIndex -= 1
            }

        } else if (ev.key == 'ArrowLeft') {
            console.log("key: ArrowLeft"); 
            // Left arrow key
            if (cursorIndex > 0) {
                cursorIndex -= 1
                term.bringCursorBackwards(1)
                post = input.slice(cursorIndex)
            }
        } else if (ev.key == 'ArrowRight') {
            console.log("key: ArrowRight"); 
            // Right arrow key
            if (cursorIndex < input.length) {
                cursorIndex += 1
                term.bringCursorForwards(1)
                post = input.slice(cursorIndex)
            }

        } else if (ev.key == 'ArrowUp'){
            console.log("key: ArrowUp"); 
            // Up arrow key - go backwards in input command history
            ev.preventDefault()
            if (historyIndex == inputHistory.length) {
                // User is moving from their current input into past inputs -
                // save what they've currently written
                saveInput = input
            }

            if (historyIndex >= 0 && inputHistory.length > 0) {
                if (historyIndex != 0) {
                    historyIndex -= 1
                }

                // Clear the line
                term.deleteLine()
                term.write('\b \b')

                // Write the previous input
                input = inputHistory[historyIndex]
                term.write(input)
                cursorIndex = input.length
            }
        } else if (ev.key == 'ArrowDown') {
            console.log("key: ArrowDown"); 
            // Down arrow key - go forwards in input command history
            ev.preventDefault()
            if (historyIndex < inputHistory.length - 1) {
                historyIndex += 1

                // Clear the line
                term.deleteLine()
                term.write('\b \b')

                // Write the next input
                input = inputHistory[historyIndex]
                term.write(input)
                cursorIndex = input.length

            } else if (historyIndex == inputHistory.length - 1) {
                console.log("key: historyIndex == inputHistory.length - 1"); 
                // User has come back to (what was) their current input
                historyIndex += 1

                // Clear the line
                term.deleteLine()
                term.write('\b \b')

                // Rewrite their old current input
                input = saveInput
                term.write(input)
                cursorIndex = input.length
            }

        } else if (ev.key == 'Tab') {

            console.log("key: Tab"); 
            // Tab - 4 spaces to make backspaces easier
            ev.preventDefault()
            input += "    "
            term.write("    ")
            cursorIndex += 4
        } else if (printable) {
            console.log("key: printable"); 
            // regular input
            if (post.length > 0) {
                console.log("    post.length > 0"); 
                // We have to re-position post, or else we'll write over it

                // Save the stuff that we want to keep
                pre = input.slice(0, cursorIndex)
                pki = cursorIndex

                // Clear the line
                term.deleteLine()
                term.write('\b \b')

                // Write down the new input
                input = pre + key + post
                term.write(input)
                term.bringCursorBackwards(post.length)
                cursorIndex = pki
            } else {
                console.log("    post.length <= 0"); 
                input += key
                term.write(key);
            }
            cursorIndex += 1
        }
    });
};

$(document).ready(function(){
    createTerminal();
});

    var resize_timer;
    $(window).on('resize', function(){

        clearTimeout(resize_timer);
        resize_timer = setTimeout(function(){
            console.log("resizing");
            $("#terminal").empty();            
            createTerminal();
        }, 250);
    });

    $(".figures-close").on('touchstart click', function(event){
        console.log(".figures-close: touchstart click");
        if(event.handled === false) return
        event.stopPropagation();
        event.preventDefault();
        event.handled = true;
       
        $(".figures-outer").hide();
        $("#figures-img").prop("src", "");
        $("#figures-caption").text("");
    });
</script>
   
</body>
</html>
